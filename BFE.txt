BFE Solutions

163   const lookup = [
  { symbol: 'M', value: 1000 },
  { symbol: 'CM', value: 900 },
  { symbol: 'D', value: 500 },
  { symbol: 'CD', value: 400 },
  { symbol: 'C', value: 100 },
  { symbol: 'XC', value: 90 },
  { symbol: 'L', value: 50 },
  { symbol: 'XL', value: 40 },
  { symbol: 'X', value: 10 },
  { symbol: 'IX', value: 9 },
  { symbol: 'V', value: 5 },
  { symbol: 'IV', value: 4 },
  { symbol: 'I', value: 1 },
]
const integerToRoman = (num, res = '') => {
  if (num > 0) {
    const { symbol, value } = lookup.find(({ value }) => num >= value)
    return integerToRoman(num - value, `${res}${symbol}`)
  }
  return res
}


133:
function romanToInteger(str) {
  // your code here
  const numerals = new Map([
    ["I", 1],
    ["V", 5],
    ["X", 10],
    ["L", 50],
    ["C", 100],
    ["D", 500],
    ["M", 1000],
  ])
  
  const backwards = str.split('').reverse()
  
  let prev = 0;
  return backwards.reduce((sum, char) => {
    const value = numerals.get(char) 
    sum = sum + ((value >= prev) ? value : -value)
    prev = value
    
    return sum
  }, 0)
}


105: function firstDuplicate(str) {
  const obj = {};

  for(let i of str){
    if(obj[i]) return i;
    obj[i] = true;
  }

  return null
}


107: function largestDiff(arr) {
  // your code here
  if(arr.length < 2) return 0;
  let min = Infinity;
  let max = -Infinity;
  for(let i= 0 ;i< arr.length;i++) {
    min = Math.min(arr[i], min);
    max = Math.max(arr[i], max);
  }
  return Math.abs(min-max);
  
}

168: function moveZeros(list) {
  // your code here
   let idx = 0;
  for (let i = 0; i < list.length; i++) {
    if (list[i] !== 0) {
      list[idx++] = list[i]
    }
  }
  while (idx < list.length) {
    list[idx++] = 0;
  }
}

165. function removeChars(input) {
  // your code here
   const stack = []

  for (let i = 0; i < input.length; i++) {
    const character = input[i]
    if (stack.length && character === 'c' && stack[stack.length - 1] === 'a') {
      stack.pop()
    } else if (character !== 'b') {
      stack.push(character)
    }
  }

  return stack.join('')
}


167. function getIntersection(arr1, arr2) {
  // your code here
  let a = new Set(arr1);
  let result = [];
  for (const item of arr2) {
    if (a.has(item)) {
      result.push(item);
      a.delete(item)
    }
  }
  return result;
}


100. Detect circle in linked list function hasCircle(head) {
*   // your code here
*   let fast = head
*   let slow = head
*   while (fast && slow) {
*     fast = fast.next?.next
*     slow = slow.next
*     if (fast === slow) {
*       return true
*     }
*   }
*   return false
* }

102. validate string of parentheses
function validate(str) {
  // your code here
  if(str.length % 2 !== 0) return false;
  const stack = [];
  const bracketMap = {
    "}": "{",
    ")" : "(",
    "]" : "[",
  }
  for(let i=0; i<str.length; i++){
    if(["(", "[", "{"].includes(str[i])) stack.push(str[i]);
    else if(stack.pop() !== bracketMap[str[i]]) return false;
  }
  return !stack.length;
}

138: Intersection of two sorted Arrays function intersect(arr1, arr2) {
  // your code here
  let p1 = 0
  let p2 = 0
  let result = []
  while (p1 < arr1.length && p2 < arr2.length) {
    if (arr1[p1] === arr2[p2]) {
      result.push(arr1[p1])
      p1 += 1
      p2 += 1
    } else {
      if (arr1[p1] < arr2[p2]) {
        p1 += 1
      } else {
        p2 += 1
      }
    }
  }
  return result
}

48. search first index with Binary Search(possible duplicate array)
function firstIndex(arr, target){
  // your code here
  let left = 0, right = arr.length - 1;
  let result = -1;
  while (left <= right) {
    const mid = Math.floor((left + right) / 2);
    if (arr[mid] === target) {
      result = mid;
      right = mid -1;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return result;
}

49. Last Index
function lastIndex(arr, target){
  // your code here
  let left = 0, right = arr.length, result = -1;
  while(left <= right) {
    const mid = Math.floor((left + right) / 2);
    if (arr[mid] === target) {
      result = mid;
      left = mid + 1;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return result;
}

93. Fibonacci with memo: function fib(n, memo = {}){
*   if (n === 0) return 0;
*   if (n === 1) return 1;
*   if (!memo[n]) {
*      memo[n] = fib(n - 1, memo) + fib(n - 2, memo);
*   } 
*   return memo[n];
}  37: Binary Search 
function binarySearch(arr, target){
  // your code here
   let start = 0, end = arr.length - 1;
  while(start <= end){
    const mid = start + Math.floor((end - start)/2);
    if(arr[mid] === target) return mid;
    else if(arr[mid] < target) start = mid + 1;
    else end = mid - 1;
  }
  return -1;
}

50. search element right before target with Binary Search(possible duplicate array) function elementBefore(arr, target){
  // your code here
  let start = 0, end = arr.length - 1;
  while(start <= end){
    const mid = start + Math.floor((end - start) / 2);
    if(arr[mid] === target){
      if(arr[mid - 1] !== target) return arr[mid - 1];
      end = mid - 1;
    }else if(arr[mid] < target) start = mid + 1;
    else end = mid - 1;
  }
}

51. search element right after target with Binary Search(possible duplicate array)
function elementAfter(arr, target){
  // your code here
   let left = 0, right = arr.length - 1, result = -1;
  while(left <= right) {
    const middle = Math.floor(left + right);
    if (arr[middle] === target) {
      result = middle;
      left = middle + 1;
    } else if (arr[middle] > target) {
      right = middle - 1;
    } else {
      left = middle + 1;
    }
  }
  
  return result > 0 ? arr[result + 1] : undefined;
}

 
66. remove Duplicates from array
function deduplicate(arr) {
   const seen = new Set();
  let i = 0;
  while (i < arr.length) {
    const val = arr[i];
    if (seen.has(val)) {
      arr[i] = arr[arr.length - 1];
      arr.pop();
    } else {
      seen.add(val);
      i++;
    }
  }
}

64. retry promise
function fetchWithAutoRetry(fetcher, maximumRetryCount) {
  // your code here
   return fetcher().catch((e) => {
    if (maximumRetryCount === 0) {
      throw e 
    } else {
      return fetchWithAutoRetry(fetcher, maximumRetryCount - 1)
    }
  })
}

166.Validate Number String
function validateNumberString(str) {
  return str !=="" && !isNaN(str)
}

157. semver compare
const getVersion = (str) => str.split('.').map(Number);
function compare(v1, v2) {
  const version1 = getVersion(v1);
  const version2 = getVersion(v2);
  for (let i = 0; i < 3; i++) {
    if (version1[i]> version2[i]) return 1;
    if (version1[i] < version2[i]) return -1;
  }
  return 0;
}
